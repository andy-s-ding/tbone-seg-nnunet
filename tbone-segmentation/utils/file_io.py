"""
file_io.py
"""

import nrrd
import ants
from ants.utils import convert_nibabel as cn
import nibabel as nib
import numpy as np
import pyvista as pv
import vtk

import os 
import sys 
import pickle

from .mask import get_bounding_box


def adjust_file_path(save_dir, prefix, suffix, downsample=None, downsample_size=300, registration="syn80-demons", is_annotation=False, flip=False):
	path = os.path.join(save_dir, prefix)
	if registration:
		path += "-" + registration
	if downsample:
		path += "-downsample%d" % (downsample_size)
	if flip:
		path += "-flipped"
	if is_annotation:
		path += "-annotations"
	path += suffix
	print(" -- returning path: %s" % path)
	return path

def get_segmentation_names(header, indices=None): 

	if indices is None: 
		num_indices = len([key for key in header.keys() if "_Name" in key and "AutoGenerated" not in key])
		indices = list(range(num_indices))

	return [header["Segment%d_Name" % (idx)] for idx in indices]


def get_label_values(header, indices=None): 
	"""get_label_values
	
	If we have a segmentation file which is a (x_dim, y_dim, z_dim) 
	ndarray where at each position we have a natural number denoting 
	a specific segment label, but we are concerned that these values 
	are not the segment indices indexed from 1, then we want to use this 
	function to parse the header and extract the actual label values.

	smh @slicer

	Args:
	    header (OrderedDict): header from nrrd.read
	    indices (None, optional): optional segments to choose from? 
	
	Returns:
	    List: list of the label values
	"""
	label_values = []
	num_segments = len([key for key in header.keys() if "LabelValue" in key])
	for i in range(num_segments):
		label_values.append(int(header['Segment{}_LabelValue'.format(i)]))
	return label_values


def get_layer_values(header, indices=None):
	"""get_layer_values
	
	If we have a segmentation file which is a (x_dim, y_dim, z_dim) 
	ndarray where at each position we have a natural number denoting 
	a specific segment label, but we are concerned that these values do not
	correspond to separate segment layers, then we want to use this 
	function to parse the header and extract the actual layer values.

	smh @slicer

	Args:
	    header (OrderedDict): header from nrrd.read
	    indices (None, optional): optional segments to choose from? 
	
	Returns:
	    List: list of the label values
	"""
	layer_values = []
	num_segments = len([key for key in header.keys() if "Layer" in key])
	for i in range(num_segments):
		layer_values.append(int(header['Segment{}_Layer'.format(i)]))
	return layer_values


def convert_to_one_hot(data, header, segment_indices=None): 

	print("-- converting to one hot")

	layer_values = get_layer_values(header)
	label_values = get_label_values(header)

	# Newer Slicer NRRD (compressed layers)
	if layer_values and label_values:

		assert len(layer_values) == len(label_values)
		if len(data.shape) == 3:
			x_dim, y_dim, z_dim = data.shape
		elif len(data.shape) == 4:
			x_dim, y_dim, z_dim = data.shape[1:]

		num_segments = len(layer_values)
		print("Number of segments: {}".format(num_segments))
		one_hot = np.zeros((num_segments, x_dim, y_dim, z_dim))

		if segment_indices is None:
			segment_indices = list(range(num_segments))

		elif isinstance(segment_indices, int):
			segment_indices = [segment_indices]

		elif not isinstance(segment_indices, list):
			print("incorrectly specified segment indices")
			return

		# Check if NRRD is composed of one layer 0
		if np.max(layer_values) == 0:
			for i, seg_idx in enumerate(segment_indices):
				layer = layer_values[seg_idx]
				label = label_values[seg_idx]
				one_hot[i] = 1*(data == label).astype(np.uint8)

		else:
			for i, seg_idx in enumerate(segment_indices):
				layer = layer_values[seg_idx]
				label = label_values[seg_idx]
				one_hot[i] = 1*(data[layer] == label).astype(np.uint8)
	
	# Binary labelmap
	elif len(data.shape) == 3:
		x_dim, y_dim, z_dim = data.shape
		num_segments = np.max(data)
		one_hot = np.zeros((num_segments, x_dim, y_dim, z_dim))

		if segment_indices is None: 
			segment_indices = list(range(1, num_segments + 1))

		elif isinstance(segment_indices, int): 
			segment_indices = [segment_indices]

		elif not isinstance(segment_indices, list): 
			print("incorrectly specified segment indices")
			return

		for i, seg_idx in enumerate(segment_indices): 
			one_hot[i] = 1*(data == seg_idx).astype(np.uint8)

	# Older Slicer NRRD (already one-hot)
	else:
		return data

	print("One-Hot Shape: {}".format(one_hot.shape))
	return one_hot


def name_consistency_check(names1, names2): 

	for name1, name2 in zip(names1, names2): 
		if name1 != name2: 
			print("%s and %s do not match" % (name1, name2))

	return

def read_vtk(file_path, use_vtk=False, as_pyvista=False):

	if use_vtk: 
		print('using vtk, not pyvista')
		reader = vtk.vtkXMLPolyDataReader()
		reader.SetFileName(file_path)
		reader.Update()
		polydata = reader.GetOutput()

		if as_pyvista: 
			return pv.wrap(polydata)

		return polydata

	mesh = pv.read(file_path)

	return mesh

def ants_image_to_file(ants_img, template_header, spatial_header, file_name, segmentations=True, nifti=False): 
	"""write out an ants image using nrrd 
	
	Note that the ANTsImage format is by default (x_dim, y_dim, z_dim, n_channels) 
	where the last dimension corresponds to the number of channels.
	
	The np.moveaxis() function is used to reshape this to be (n_channels, x_dim, y_dim, z_dim)
	which is the default option for nrrd writing. 
	
	Args:
	    ants_img (ANTsImage): the image to be written out
	    target_header (OrderedDict): ordered dictionary corresponding to the header info 
	    file_name (str): desired output file name
	
	Returns:
	    None
	"""
	print(ants_img.shape)
	img_as_np = ants_img.view(single_components=segmentations)
	print('image as numpy shape', img_as_np.shape)

	if nifti:
		if segmentations:
			data = convert_to_one_hot(img_as_np, template_header)
			foreground = np.max(data, axis=0)
			labelmap = np.multiply(np.argmax(data, axis=0) + 1, foreground).astype('uint8')
			segmentation_img = ants.from_numpy(labelmap, origin=ants_img.origin, spacing = ants_img.spacing, direction=ants_img.direction)
			print('-- Saving NII Segmentations')
			segmentation_img.to_filename(file_name)
		else:
			print('-- Saving NII Volume')
			ants_img.to_filename(file_name)
	else:
		# copy over image spacing
		template_header['spacing'] = ants_img.spacing

		# copy over the space coordinate frame and spatial origin
		template_header['space'] = spatial_header['space']
		template_header['space origin'] = spatial_header['space origin']

		if segmentations:
			# copy over spatial directions (3,3).
			# add offset if the template_header is (3,3)
			# so that the final output is (4,3)
			if template_header['space directions'].shape[0] == 4: 
				template_header['space directions'][1:] = spatial_header['space directions'][-3:]
			else: 
				nan = np.ones((1, 3))*np.nan
				template_header['space directions'] = np.concatenate((nan, spatial_header['space directions']))
				template_header['kinds'].insert(0, 'list')

			# update the segment extents by finding bounding box for each segmentation. This will slightly
			# increase slicer speed for reading in the segmentation. 
			seg_layers = get_layer_values(template_header)
			if len(seg_layers) > 1: # If seg file is new version with multiple layers
				bbox_strings = get_bounding_box(img_as_np)
				for idx in range(len(seg_layers)):
					template_header["Segment%d_Extent" % (idx)] = bbox_strings[seg_layers[idx]] # Segments in same layer have same extent
			else: # If seg file is old version or has one layer
				image_one_hot = convert_to_one_hot(img_as_np, template_header)
				bbox_strings = get_bounding_box(image_one_hot)
				for idx, bbox_string in enumerate(bbox_strings):
					template_header["Segment%d_Extent" % (idx)] = bbox_string

			nrrd.write(file_name, img_as_np, template_header)

		else:
			template_header['space directions'] = spatial_header['space directions']
			nrrd.write(file_name, img_as_np, template_header)

	return

def print_scores(scores, names=None): 

	if names is None: 
		names = ["[[%d]]"%idx for idx in range(len(scores))]

	if len(names) != len(scores): 
		print('---- error in specifying names associated with scores')

	for name, score in zip(names, scores): 
		print('score for %s is %f'%(name, score))

	print('--'*10)

	return


def check_if_cached(file_path): 

	if os.path.exists(os.path.join("pickles", file_path)):
		return os.path.join("pickles", file_path)
	else: 
		return False


def write_to_file(name, obj):
	'''
	Write object of specified name to a pickle file 
	
	Args:
	    name (TYPE): Description
	    obj (TYPE): Description
	
	Returns:
	    TYPE: Description
	'''

	print('writing structures to pickle')
	print('----------------------------')

	path = os.path.join(os.getcwd(), "pickles/" + name + ".pkl")
	file = open(path, 'wb')
	pickle.dump(obj, file)
	file.close()

	return


def read_from_file(name):
	'''
	Return loaded object given by input name
	
	Args:
	    name (TYPE): Description
	
	Returns:
	    TYPE: Description
	'''
	print('reading structures from pickle')
	print('------------------------------')

	path = os.path.join(os.getcwd(), "pickles/" + name + ".pkl")
	file = open(path, 'rb')
	new_obj = pickle.load(file)
	file.close()

	return new_obj


def main(): 
	# test_ants_image_write()
	return


if __name__ == "__main__":
	 main()
