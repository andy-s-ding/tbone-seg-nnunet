"""
file_io.py
"""

import nrrd
import ants
import numpy as np
import pyvista as pv
import vtk

import os 
import sys 
import pickle

from .mask import get_bounding_box


def get_segmentation_names(header, indices=None): 

	if indices is None: 
		num_indices = len([key for key in header.keys() if "_Name" in key and "AutoGenerated" not in key])
		indices = list(range(num_indices))

	return [header["Segment%d_Name" % (idx)] for idx in indices]


def get_label_values(header, indices=None): 
	"""get_label_values
	
	If we have a segmentation file which is a (x_dim, y_dim, z_dim) 
	ndarray where at each position we have a natural number denoting 
	a specific segment label, but we are concerned that these values 
	are not the segment indices indexed from 1, then we want to use this 
	function to parse the header and extract the actual label values.

	smh @slicer

	Args:
	    header (OrderedDict): header from nrrd.read
	    indices (None, optional): optional segments to choose from? 
	
	Returns:
	    List: list of the label values
	"""
	label_values = []
	num_segments = len([key for key in header.keys() if "LabelValue" in key])
	for i in range(num_segments):
		label_values.append(int(header['Segment{}_LabelValue'.format(i)]))
	return label_values


def get_layer_values(header, indices=None):
	"""get_layer_values
	
	If we have a segmentation file which is a (x_dim, y_dim, z_dim) 
	ndarray where at each position we have a natural number denoting 
	a specific segment label, but we are concerned that these values do not
	correspond to separate segment layers, then we want to use this 
	function to parse the header and extract the actual layer values.

	smh @slicer

	Args:
	    header (OrderedDict): header from nrrd.read
	    indices (None, optional): optional segments to choose from? 
	
	Returns:
	    List: list of the label values
	"""
	layer_values = []
	num_segments = len([key for key in header.keys() if "Layer" in key])
	for i in range(num_segments):
		layer_values.append(int(header['Segment{}_Layer'.format(i)]))
	return layer_values


def convert_to_one_hot(data, header, segment_indices=None): 

	print("-- converting to one hot")

	layer_values = get_layer_values(header)
	label_values = get_label_values(header)

	# Newer Slicer NRRD (compressed layers)
	if layer_values and label_values:

		assert len(layer_values) == len(label_values)
		if len(data.shape) == 3:
			x_dim, y_dim, z_dim = data.shape
		elif len(data.shape) == 4:
			x_dim, y_dim, z_dim = data.shape[1:]

		num_segments = len(layer_values)
		print("Number of segments: {}".format(num_segments))
		one_hot = np.zeros((num_segments, x_dim, y_dim, z_dim))

		if segment_indices is None:
			segment_indices = list(range(num_segments))

		elif isinstance(segment_indices, int):
			segment_indices = [segment_indices]

		elif not isinstance(segment_indices, list):
			print("incorrectly specified segment indices")
			return

		# Check if NRRD is composed of one layer 0
		if np.max(layer_values) == 0:
			for i, seg_idx in enumerate(segment_indices):
				layer = layer_values[seg_idx]
				label = label_values[seg_idx]
				one_hot[i] = 1*(data == label).astype(np.uint8)

		else:
			for i, seg_idx in enumerate(segment_indices):
				layer = layer_values[seg_idx]
				label = label_values[seg_idx]
				one_hot[i] = 1*(data[layer] == label).astype(np.uint8)
	
	# Binary labelmap
	elif len(data.shape) == 3:
		x_dim, y_dim, z_dim = data.shape
		num_segments = np.max(data)
		one_hot = np.zeros((num_segments, x_dim, y_dim, z_dim))

		if segment_indices is None: 
			segment_indices = list(range(1, num_segments + 1))

		elif isinstance(segment_indices, int): 
			segment_indices = [segment_indices]

		elif not isinstance(segment_indices, list): 
			print("incorrectly specified segment indices")
			return

		for i, seg_idx in enumerate(segment_indices): 
			one_hot[i] = 1*(data == seg_idx).astype(np.uint8)

	# Older Slicer NRRD (already one-hot)
	else:
		return data

	print(one_hot.shape)
	return one_hot


def name_consistency_check(names1, names2): 

	for name1, name2 in zip(names1, names2): 
		if name1 != name2: 
			print("%s and %s do not match" % (name1, name2))

	return


def read_vtk(file_path, use_vtk=False, as_pyvista=False):

	if use_vtk: 
		print('using vtk, not pyvista')
		reader = vtk.vtkXMLPolyDataReader()
		reader.SetFileName(file_path)
		reader.Update()
		polydata = reader.GetOutput()

		if as_pyvista: 
			return pv.wrap(polydata)

		return polydata

	mesh = pv.read(file_path)

	return mesh


def extract_landmarks(segmentation_nrrds, segmentation_dir, output_dir):
	"""Summary
	
	return a dictionary {
		Segment_Name: mesh 
	}
	
	Args:
	    segmentation_nrrds (TYPE): Description
	    segmentation_dir (TYPE): Description
	    output_dir (TYPE): Description
	
	
	"""
	landmark_indices = {
		''
	}
	for i, nrrd_num in enumerate(segmentation_nrrds):
		path_seg_nrrd = os.path.join(segmentation_dir, "Segmentation %s %s.seg.nrrd" % (side, nrrd_num)) 
		data, header = nrrd.read(path_seg_nrrd)


def ants_image_to_file(ants_img, template_header, spatial_header, file_name): 
	"""write out an ants image using nrrd 
	
	Note that the ANTsImage format is by default (x_dim, y_dim, z_dim, n_channels) 
	where the last dimension corresponds to the number of channels.
	
	The np.moveaxis() function is used to reshape this to be (n_channels, x_dim, y_dim, z_dim)
	which is the default option for nrrd writing. 
	
	Args:
	    ants_img (ANTsImage): the image to be written out
	    target_header (OrderedDict): ordered dictionary corresponding to the header info 
	    file_name (str): desired output file name
	
	Returns:
	    None
	"""
	print(template_header)
	print(ants_img.shape)
	img_as_np = ants_img.numpy(single_components=True)
	print('image as numpy shape', img_as_np.shape)
	print('new view shape', np.moveaxis(img_as_np, -1, 0).shape)

	# copy over image spacing
	template_header['spacing'] = ants_img.spacing

	# copy over the space coordinate frame and spatial origin
	template_header['space'] = spatial_header['space']
	template_header['space origin'] = spatial_header['space origin']

	# copy over spatial directions (3,3).
	# add offset if the template_header is (3,3)
	# so that the final output is (4,3)
	if template_header['space directions'].shape[0] == 4: 
		template_header['space directions'][1:] = spatial_header['space directions']
	else: 
		nan = np.ones((1, 3))*np.nan
		template_header['space directions'] = np.concatenate((nan, spatial_header['space directions']))
		template_header['kinds'].insert(0, 'list')

	# update the segment extents by finding bounding box for each segmentation. This will slightly
	# increase slicer speed for reading in the segmentation. 
	bbox_strings = get_bounding_box(np.moveaxis(img_as_np, -1, 0))
	for idx, bbox_string in enumerate(bbox_strings): 
		template_header["Segment%d_Extent" % (idx)] = bbox_string

	# write out the file with the updated header
	nrrd.write(file_name, np.moveaxis(img_as_np, -1, 0), template_header)
	
	return


def adjust_path(path_input, folder="mesh_output"): 

	adjusted_path = ""

	if path_input is None: 
		cur_outs = os.listdir(os.path.join(os.getcwd(), "test"))
		next_avail = len([file for file in cur_outs if (".vtk" in file) and ("test" in file)])
		adjusted_path = "test/test_%d.vtk" % (next_avail)

	elif ".vtk" in path_input: 
		adjusted_path = os.path.join(folder, path_input)

	else: 
		adjusted_path = os.path.join(folder, path_input + ".vtk")

	return os.path.abspath(adjusted_path)


def print_scores(scores, names=None): 

	if names is None: 
		names = ["[[%d]]"%idx for idx in range(len(scores))]

	if len(names) != len(scores): 
		print('---- error in specifying names associated with scores')

	for name, score in zip(names, scores): 
		print('score for %s is %f'%(name, score))

	print('--'*10)

	return


def check_if_cached(file_path): 

	if os.path.exists(os.path.join("pickles", file_path)):
		return os.path.join("pickles", file_path)
	else: 
		return False


def write_to_file(name, obj):
	'''
	Write object of specified name to a pickle file 
	
	Args:
	    name (TYPE): Description
	    obj (TYPE): Description
	
	Returns:
	    TYPE: Description
	'''

	print('writing structures to pickle')
	print('----------------------------')

	path = os.path.join(os.getcwd(), "pickles/" + name + ".pkl")
	file = open(path, 'wb')
	pickle.dump(obj, file)
	file.close()

	return


def read_from_file(name):
	'''
	Return loaded object given by input name
	
	Args:
	    name (TYPE): Description
	
	Returns:
	    TYPE: Description
	'''
	print('reading structures from pickle')
	print('------------------------------')

	path = os.path.join(os.getcwd(), "pickles/" + name + ".pkl")
	file = open(path, 'rb')
	new_obj = pickle.load(file)
	file.close()

	return new_obj


def main(): 
	# test_ants_image_write()
	return


if __name__ == "__main__":
	 main()
